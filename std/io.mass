exports [.print]

// TODO figure out how to do it with OS support
//cached_stdout_handle := 0
//startup(fn() {
  //// TODO this cast should not be necessary but it is unclear
  ////      how this implicit cast from a statically known value
  ////      should look like in the user land
  //cached_stdout_handle = GetStdHandle(cast(s32, -11))
//})

native_stdout :: fn(buffer : &i8, size : i64) -> () {
  if get_target_os() == os.Windows then {
    win32 :: import("std/win32")
    handle := win32.GetStdHandle(cast(s32, -11))
    win32.WriteFile(handle, buffer, cast(s32, size), 0, 0)
  } else {
    linux :: import("std/linux")
    linux.sys_write(linux.STDOUT_FILENO, buffer, size)
  }
}

print :: macro(string : String) -> () {
  native_stdout(string.bytes, string.length)
}

print :: fn(x : s64) {
  // TODO replace with shadowing an arg with a local when supported
  integer := x
  count := {
    count := 0
    temp := integer
    while temp != 0 {
      count = count + 1
      temp = temp / 10
    }
    if count != 0 then count else 1
  }

  buffer : i8*64
  output_size := if integer < 0 then {
    minus_code :: string_get("-", 0)
    buffer.0 = minus_code
    integer = 0 - integer
    count + 1
  } else {
    count
  }

  using unsigned
  integer_index := 0
  while integer_index < count {
    integer_index = integer_index + 1
    digit := cast(u8, integer % 10)
    digit_index := output_size - integer_index
    zero_code :: string_get("0", 0)
    buffer.(digit_index) = cast(i8, cast(u8, zero_code) + digit)
    integer = integer / 10
  }
  native_stdout(&buffer, cast(i64, output_size))
}
