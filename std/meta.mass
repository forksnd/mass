exports [.reify, .static_value, .immediate, .same_type, .compilation_error, .context_error, .Value]

Value :: MASS.Value
Source_Range :: MASS.Source_Range
same_type :: MASS.same_type

compilation_error :: fn(context : &MASS.Compilation, error : MASS.Error) {
  assert(context.result.tag == MASS.Result_Tag.Success)
  context.result.tag = MASS.Result_Tag.Error
  context.result.Error.error = error
}

context_error :: fn(context : &MASS.Context, error : MASS.Error) {
  compilation_error(context.compilation, error)
}

pointer_from_static_value :: fn(value : &Value, type : Type) -> (&type_of(())) {
  assert(same_type(value.descriptor, type))
  assert(value.descriptor.bit_size.as_u64 == value.storage.bit_size.as_u64)

  if value.storage.tag == MASS.Storage_Tag.Static then {
    value.storage.Static.pointer
  } else if value.storage.tag == MASS.Storage_Tag.Immediate then {
    &value.storage.Immediate.bits
  } else {
    assert(value.storage.tag == MASS.Storage_Tag.Static)
    0
  }
}

is_pointer_type :: fn(type : Type) => (Type) {
  if type.tag == MASS.Descriptor_Tag.Pointer_To then type else 0
}

static_value :: fn(
  compilation : &MASS.Compilation,
  pointer ~ is_pointer_type,
  source_range : Source_Range
) -> (&Value) {
  type :: type_of(pointer)
  static_assert(type.tag == MASS.Descriptor_Tag.Pointer_To)
  pointee_type :: type.Pointer_To.descriptor

  static_value := allocate(compilation.allocator, Value)
  static_value.source_range = source_range
  static_value.descriptor = pointee_type

  static_value.storage.tag = MASS.Storage_Tag.Static
  static_value.storage.bit_size = pointee_type.bit_size

  static_assert(unsigned_greater(cast(i64, pointee_type.bit_size.as_u64), 64))
  static_value.storage.Static.pointer = pointer

  static_value
}

immediate :: fn(
  compilation : &MASS.Compilation,
  source,
  source_range : Source_Range
) -> (&Value) {
  type :: type_of(source)
  static_assert(
    unsigned_less_equal(cast(i64, type.bit_size.as_u64), 64),
    "Type is too large to fit into an immediate"
  )

  static_value := allocate(compilation.allocator, Value)
  static_value.source_range = source_range
  static_value.descriptor = type

  static_value.storage.tag = MASS.Storage_Tag.Immediate
  static_value.storage.bit_size = type.bit_size
  cast(type, static_value.storage.Immediate.bits) = source

  static_value
}

reify :: macro(value : &Value, type : Type) {
  cast(&type, pointer_from_static_value(value, type))
}
