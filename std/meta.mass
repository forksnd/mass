exports { reify, static_value, immediate, same_type, compilation_error, context_error, Value }

Value :: MASS.Value
Source_Range :: MASS.Source_Range
Execution_Context :: MASS.Execution_Context
same_type :: MASS.same_type

compilation_error :: fn(context : &MASS.Compilation, error : MASS.Error) {
  assert(context.result.tag == MASS.Result_Tag.Success)
  context.result.tag = MASS.Result_Tag.Error
  context.result.Error.error = error
}

context_error :: fn(context : &MASS.Execution_Context, error : MASS.Error) {
  compilation_error(context.compilation, error)
}

pointer_from_static_value :: fn(value : &Value, type : Type) -> (&type_of(())) {
  assert(value.storage.tag == MASS.Storage_Tag.Static)
  assert(same_type(value.descriptor, type))
  assert(value.descriptor.bit_size.as_u64 == value.storage.bit_size.as_u64)
  memory := &value.storage.Static.memory
  Tag :: MASS.Static_Memory_Tag

  if memory.tag == Tag.Heap then {
    memory.Heap.pointer
  } else if memory.tag == Tag.U64 then {
    &memory.U64.value
  } else if memory.tag == Tag.U32 then {
    &memory.U32.value
  } else if memory.tag == Tag.U16 then {
    &memory.U16.value
  } else if memory.tag == Tag.U8 then {
    &memory.U8.value
  } else {
    assert(false, "unreacheable")
    0
  }
}

static_value :: fn(
  compilation : &MASS.Compilation,
  pointer,
  source_range : Source_Range
) -> (&Value) {
  type :: type_of(pointer)
  static_assert(type.tag == MASS.Descriptor_Tag.Pointer_To)

  static_value := allocate(compilation.allocator, Value)
  static_value.source_range = source_range
  static_value.descriptor = type.Pointer_To.descriptor

  static_value.storage.tag = MASS.Storage_Tag.Static
  static_value.storage.bit_size = static_value.descriptor.bit_size

  bit_size := static_value.descriptor.bit_size.as_u64
  if bit_size == 8 then {
    static_value.storage.Static.memory.tag = MASS.Static_Memory_Tag.U8
    static_value.storage.Static.memory.U8.value = cast(&u8, pointer).*
  } else if bit_size == 16 then {
    static_value.storage.Static.memory.tag = MASS.Static_Memory_Tag.U16
    static_value.storage.Static.memory.U16.value = cast(&u16, pointer).*
  } else if bit_size == 32 then {
    static_value.storage.Static.memory.tag = MASS.Static_Memory_Tag.U32
    static_value.storage.Static.memory.U32.value = cast(&u32, pointer).*
  } else if bit_size == 64 then {
    static_value.storage.Static.memory.tag = MASS.Static_Memory_Tag.U64
    static_value.storage.Static.memory.U64.value = cast(&u64, pointer).*
  } else {
    static_value.storage.Static.memory.tag = MASS.Static_Memory_Tag.Heap
    static_value.storage.Static.memory.Heap.pointer = pointer
  }

  static_value
}

immediate :: fn(
  compilation : &MASS.Compilation,
  source,
  source_range : Source_Range
) -> (&Value) {
  type :: type_of(source)
  // TODO this is quite awkward. Probably bit_size should be i64 and use unsigned compare
  static_assert(@{type.bit_size.as_u64 <= 64}, "Type is too large to fit into an immediate")

  static_value := allocate(compilation.allocator, Value)
  static_value.source_range = source_range
  static_value.descriptor = type

  static_value.storage.tag = MASS.Storage_Tag.Immediate
  static_value.storage.bit_size = type.bit_size
  cast(type, static_value.storage.Immediate.bits) = source

  static_value
}

reify :: macro(value : &Value, type : Type) {
  cast(&type, pointer_from_static_value(value, type))
}
