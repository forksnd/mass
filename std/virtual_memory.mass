exports [.allocate, .Permissions, .NONE, .READ, .READ_WRITE, .READ_WRITE_EXECUTE]

Permissions :: c_struct [ bits : i64 ]
NONE    :: Permissions[0]
READ    :: Permissions[1]
READ_WRITE   :: Permissions[2]
READ_WRITE_EXECUTE :: Permissions[3]

// TODO should be possible to define this equality
//equal :: fn(x : Permissions, y : Permissions) -> (bool) { x.bits == y.bits }

// TODO figure out what is the strategy for errors in Mass
allocate :: fn(size : u64, permissions : Permissions, address : &Void = 0) -> (&Void) {
  if get_target_os() == .Windows then {
    using import("std/win32")
    allocation_type :: MEM_COMMIT | MEM_RESERVE
    win32_permissions := if permissions.bits == NONE.bits then {
      PAGE_NOACCESS
    } else if permissions.bits == READ.bits then {
      PAGE_READONLY
    } else if permissions.bits == READ_WRITE.bits then {
      PAGE_READWRITE
    } else if permissions.bits == READ_WRITE_EXECUTE.bits then {
      PAGE_EXECUTE_READWRITE
    } else {
      assert(false, "UNREACHABLE")
      PAGE_NOACCESS // TODO use an assert that is changed to have `never` type
    }
    VirtualAlloc(address, size, allocation_type, win32_permissions)
  } else {
    using import("std/linux")
    // FIXME figure out how to avoid these weird casts
    linux_permissions : i32 = if permissions.bits == NONE.bits then {
      i32(PROT_NONE)
    } else if permissions.bits == READ.bits then {
      i32(PROT_READ)
    } else if permissions.bits == READ_WRITE.bits then {
      i32(PROT_READ | PROT_WRITE)
    } else if permissions.bits == READ_WRITE_EXECUTE.bits then {
      i32(PROT_READ | PROT_WRITE | PROT_EXEC)
    } else {
      assert(false, "UNREACHABLE")
      i32(PROT_NONE) // TODO use an assert that is changed to have `never` type
    }
    sys_mmap(address, size, linux_permissions, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
  }
}
