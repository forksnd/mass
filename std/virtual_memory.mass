exports [.allocate, .Permissions, .NONE, .READ, .READ_WRITE, .READ_WRITE_EXECUTE]

Permissions :: c_struct [ bits : i64 ]
NONE    :: Permissions[0]
READ    :: Permissions[1]
READ_WRITE   :: Permissions[2]
READ_WRITE_EXECUTE :: Permissions[3]

// TODO should be possible to define this equality
//equal :: fn(x : Permissions, y : Permissions) -> (bool) { x.bits == y.bits }

// TODO figure out what is the strategy for errors in Mass
allocate :: fn(size : u64, permissions : Permissions, address : &Void = 0) -> (&Void) {
  if get_target_os() == .Windows then {
    using import("std/win32")
    allocation_type :: MEM_COMMIT | MEM_RESERVE
    win32_permissions := if permissions.bits == NONE.bits then {
      PAGE_NOACCESS
    } else if permissions.bits == READ.bits then {
      PAGE_READONLY
    } else if permissions.bits == READ_WRITE.bits then {
      PAGE_READWRITE
    } else if permissions.bits == READ_WRITE_EXECUTE.bits then {
      PAGE_EXECUTE_READWRITE
    } else {
      unreachable()
    }
    VirtualAlloc(address, size, allocation_type, win32_permissions)
  } else {
    using import("std/linux")
    linux_permissions := if permissions.bits == NONE.bits then {
      PROT_NONE
    } else if permissions.bits == READ.bits then {
      PROT_READ
    } else if permissions.bits == READ_WRITE.bits then {
      PROT_READ | PROT_WRITE
    } else if permissions.bits == READ_WRITE_EXECUTE.bits then {
      PROT_READ | PROT_WRITE | PROT_EXEC
    } else {
      unreachable()
    }
    sys_mmap(address, size, cast(i32, linux_permissions), MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
  }
}
