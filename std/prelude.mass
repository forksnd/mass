syntax statement("while" ..@condition {}@body) {
  label _loop_start
  label placeholder _loop_done
  if condition() then {
    body(module {
      break :: ~> { goto _loop_done }
      continue :: ~> { goto _loop_start }
    })
    goto _loop_start
  } else {}
  label _loop_done
}

syntax statement("for" ..@pre ";" ..@condition ";" ..@post {}@body) {
  pre()

  label _loop_start
  label placeholder _loop_done
  label placeholder _loop_post
  if condition() then {
    body(module {
      break :: ~> { goto _loop_done }
      continue :: ~> { goto _loop_post }
    })
    label _loop_post
    post()
    goto _loop_start
  } else {}
  label _loop_done
}

import :: fn(path : String) => (MASS.Scope) MASS.import
cast :: @fn(type : Type, value) MASS.cast
startup :: fn(callback : fn() -> ()) => () MASS.startup
eval :: @fn(curly : MASS.Group_Curly) MASS.eval
eval :: @fn(paren : MASS.Group_Paren) MASS.eval
fragment :: fn(curly : MASS.Group_Curly) => (MASS.Code_Fragment) MASS.fragment

inline_machine_code_bytes :: MASS.inline_machine_code_bytes

debugger :: ~> { inline_machine_code_bytes(0xCC) }

Symbol :: MASS.Symbol
true :: cast(bool, 1)
false :: cast(bool, 0)

assert :: fn(condition : bool, message := "Assertion failed") {
  process :: import("std/process")
  io :: import("io")
  if condition then {} else {
    // FIXME This explodes. Maybe library import is from a wrong program?
    // io.print(message)
    process.exit(1)
  }
}

reify :: macro(value : &MASS.Value, type : Type) {
  // FIXME these casts should not be necessary and are broken probably because == does not
  //       properly release temp operands
  //assert(cast(s32, value.storage.tag) == cast(s32, MASS.Storage_Tag.Static))
  //assert(cast(s32, value.storage.Static.memory.tag) == cast(s32, MASS.Static_Memory_Tag.Heap))
  //assert(cast(s64, value.descriptor) == cast(s64, type))
  cast(&type, value.storage.Static.memory.Heap.pointer)
}

context_error :: fn(context : &MASS.Execution_Context, error : MASS.Error) {
  //assert(context.result.tag == MASS.Result_Tag.Success)
  context.result.tag = MASS.Result_Tag.Error
  context.result.Error.error = error
}

static_assert :: fn(condition : bool, message : String) => () intrinsic {
  condition := reify(arguments.values.0, bool)
  message := reify(arguments.values.1, String)

  if condition then {} else {
    error : MASS.Error
    error.tag = MASS.Error_Tag.User_Defined
    error.source_range = arguments.source_range
    error.detailed_message = message.*
    error.User_Defined.name = "Static Assert Failed"
    context_error(context, error)
  }

  void := allocate(MASS.allocator, MASS.Value)
  void.descriptor = type_of(())
  void.storage.tag = MASS.Storage_Tag.None
  void.source_range = arguments.source_range
  void
}

apply :: fn(symbol :: 'module, curly : MASS.Group_Curly) => (MASS.Scope) MASS.inline_module
apply :: fn(symbol :: 'exports, curly : MASS.Group_Curly) => () MASS.exports
apply :: fn(symbol :: 'intrinsic, curly : MASS.Group_Curly) => () MASS.intrinsic
apply :: fn(symbol :: 'c_struct, curly : MASS.Group_Square) => (Type) MASS.c_struct
apply :: macro(type, tuple : MASS.Group_Square) { cast(type', tuple') }

operator 7 (x == y) equal
operator 7 (x != y) not_equal

operator 8 (x < y) less
operator 8 (x > y) greater
operator 8 (x <= y) less_equal
operator 8 (x >= y) greater_equal

operator 10 (x + y) add
operator 10 (x - y) subtract

operator 15 (x * y) multiply
operator 15 (x / y) divide
operator 15 (x % y) remainder

operator 15 (x << y) logical_shift_left
operator 15 (x >> y) logical_shift_right
operator 15 (x | y) bitwise_or
operator 15 (x & y) bitwise_and

operator 16 (- x) negate
operator 16 (& x) pointer_to

operator intrinsic 20 (@ x) eval
operator intrinsic 25 (~> x) fragment

operator intrinsic 30 (' x) quote
operator intrinsic 30 (x ') unquote

quote :: fn(x) => (MASS.Quoted) MASS.quote
unquote :: @fn(x) MASS.unquote

type_of :: fn(x) => (Type) MASS.type_of
size_of :: fn(x) => (i64) MASS.size_of

pointer_to :: macro(type : Type) -> (Type) {
  MASS.descriptor_pointer_to(MASS.allocator, type)
}
pointer_to :: fn(x) => (pointer_to(x)) MASS.pointer_to

template_signed_integer_overloads :: macro(template, impl) {
  f :: template(impl, s64)
  f :: template(impl, s32)
  f :: template(impl, s16)
  f :: template(impl, s8)
  f
}

template_unsigned_integer_overloads :: macro(template, impl) {
  f :: template(impl, u64)
  f :: template(impl, u32)
  f :: template(impl, u16)
  f :: template(impl, u8)
  f
}

template_integer_overloads :: macro(template, impl) {
  f :: template_signed_integer_overloads(template, impl)
  f :: template_unsigned_integer_overloads(template, impl)
  f
}

arithmetic_template :: macro(impl, type : Type) {
  fn(x : type, y : type) => (type) impl
}

add :: template_integer_overloads(arithmetic_template, MASS.integer_add)
subtract :: template_integer_overloads(arithmetic_template, MASS.integer_subtract)
multiply :: template_integer_overloads(arithmetic_template, MASS.integer_multiply)
divide :: template_integer_overloads(arithmetic_template, MASS.integer_divide)
remainder :: template_integer_overloads(arithmetic_template, MASS.integer_remainder)

comparison_template :: macro(impl, type : Type) {
  fn(x : type, y : type) => (bool) impl
}

less :: template_integer_overloads(comparison_template, MASS.integer_less)
less_equal :: template_integer_overloads(comparison_template, MASS.integer_less_equal)
greater :: template_integer_overloads(comparison_template, MASS.integer_greater)
greater_equal :: template_integer_overloads(comparison_template, MASS.integer_greater_equal)
equal :: template_integer_overloads(comparison_template, MASS.integer_equal)
not_equal :: template_integer_overloads(comparison_template, MASS.integer_not_equal)


add :: MASS.i64_add
subtract :: MASS.i64_subtract
equal :: MASS.i64_equal
not_equal :: MASS.i64_not_equal
logical_shift_left :: MASS.i64_logical_shift_left
logical_shift_right :: MASS.i64_logical_shift_right
bitwise_or :: MASS.i64_bitwise_or
bitwise_and :: MASS.i64_bitwise_and

Allocator :: MASS.Allocator

allocate :: macro(allocator : &MASS.Allocator, type : Type) {
  cast(&type, MASS.allocator_allocate_bytes(
    allocator,
    type.bit_size.as_u64 / 8,
    type.bit_alignment.as_u64 / 8
  ))
}
deallocate :: macro(pointer) {
  type :: type_of(pointer)
  MASS.allocator_allocate_bytes(allocator, type.bit_size.as_u64 / 8, type.bit_alignment.as_u64 / 8)
}

Array :: fn(item : Type, length : u64) => (Type) {
  t : Type = allocate(MASS.allocator, MASS.Descriptor)

  t.tag = MASS.Descriptor_Tag.Fixed_Size_Array
  t.bit_size = [item.bit_size.as_u64 * length]
  t.bit_alignment = item.bit_alignment
  t.Fixed_Size_Array = [item, length]
  t
}

multiply :: Array

external :: fn(
  library_name : String,
  symbol_name : String
) => (MASS.External_Symbol) {
  [library_name, symbol_name]
}

syscall :: fn(number : s64) => (MASS.Syscall) { [number] }

negate :: template_signed_integer_overloads(macro(impl, type : Type) {
  macro(x : type) { 0 - x }
}, ())
negate :: macro(literal : i64) -> (s64) {
  -cast(s64, literal)
}

