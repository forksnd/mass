// TODO ..@condition should be parsed as an expression instead of a wildcard
syntax statement("if" ..@condition {}@then_branch) {
  () = if condition() then then_branch() else {}
}

// TODO ..@condition should be parsed as an expression instead of a wildcard
syntax statement("if" ..@condition {}@then_branch "else" {}@else_branch) {
  () = if condition() then then_branch() else else_branch()
}

// TODO think of a better solution
// It is a bit unfortunate that we have to define this wrapper,
// otherwise we match the block version of this which will fail
// parsing (@condition() then) as an expression
//syntax statement("if" ..@condition "then" {}@then_branch "else" {}@else_branch) (
  //if condition() then then_branch() else else_branch()
//)

syntax statement("while" ..@condition {}@body) {
  label _loop_start
  label placeholder _loop_done

  break :: ~> { goto _loop_done }
  continue :: ~> { goto _loop_start }
  if condition() {
    body(@scope)
    goto _loop_start
  }
  label _loop_done
}

syntax statement("for" ..@pre ";" ..@condition ";" ..@post {}@body) {
  pre()
  label _loop_start
  label placeholder _loop_post
  label placeholder _loop_done
  break :: ~> { goto _loop_done }
  continue :: ~> { goto _loop_post }
  if condition() {
    body(@scope)
    label _loop_post
    post()
    goto _loop_start
  }
  label _loop_end
}

PRELUDE_MASS :: import("mass")

debugger :: ~> { inline_machine_code_bytes(0xCC) }

syntax statement("goto" .@label) { inline_machine_code_bytes(0xE9, label()) }

Symbol :: PRELUDE_MASS.Symbol
String :: Slice
bool :: s8
true :: 1
false :: 0

compile_time_error :: @fn(name : String, description : String) -> () PRELUDE_MASS.compile_time_error

static_assert :: macro(condition : bool, message : String) {
  @{if condition == false { compile_time_error("Static Assert Failed", message) }}
}

operator 7 (x == y) equal(x, y)
operator 7 (x != y) not_equal(x, y)

operator 8 (x < y) less(x, y)
operator 8 (x > y) greater(x, y)
operator 8 (x <= y) less_equal(x, y)
operator 8 (x >= y) greater_equal(x, y)

operator 10 (x + y) add(x, y)
operator 10 (x - y) subtract(x, y)

operator 15 (x * y) multiply(x, y)
operator 15 (x / y) divide(x, y)
operator 15 (x % y) remainder(x, y)

operator 16 (- x) negate(x)
operator 16 (& x) address_of(x)

operator 15 (x << y) logical_shift_left(x, y)
operator 15 (x >> y) logical_shift_right(x, y)
operator 15 (x | y) bitwise_or(x, y)
operator 15 (x & y) bitwise_and(x, y)

type_of :: @fn(x) -> (Type) PRELUDE_MASS.type_of
size_of :: @fn(x) -> (Number_Literal) PRELUDE_MASS.size_of

Pointer_To :: macro(type : Type) -> (Type) {
  PRELUDE_MASS.descriptor_pointer_to(PRELUDE_MASS.allocator, type)
}
address_of :: Pointer_To

// It is technically not necessary to specify the return type here,
// but it is nice as an extra stress to the compiler.
// FIXME Using `address_of` instead of `Pointer_To` results in an infinite loop
address_of :: @fn(x) -> (Pointer_To(type_of(x))) PRELUDE_MASS.address_of

template_signed_integer_overloads :: macro(template, impl) {
  f :: template(impl, s64)
  f :: template(impl, s32)
  f :: template(impl, s16)
  f :: template(impl, s8)
  f
}

template_unsigned_integer_overloads :: macro(template, impl) {
  f :: template(impl, u64)
  f :: template(impl, u32)
  f :: template(impl, u16)
  f :: template(impl, u8)
  f
}

template_integer_overloads :: macro(template, impl) {
  f :: template(impl, Number_Literal)
  f :: template_signed_integer_overloads(template, impl)
  f :: template_unsigned_integer_overloads(template, impl)
  f
}

arithmetic_template :: macro(impl, type : Type) {
  @fn(x : type, y : type) -> (bool) impl
}
// TODO support arithmetic on Number_Literal and remove this overload
arithmetic_template :: macro(impl, type :: Number_Literal) {
  @fn(x : Number_Literal, y : Number_Literal) -> (s64) impl
}

add :: template_integer_overloads(arithmetic_template, PRELUDE_MASS.add)
subtract :: template_integer_overloads(arithmetic_template, PRELUDE_MASS.subtract)
multiply :: template_integer_overloads(arithmetic_template, PRELUDE_MASS.multiply)
divide :: template_integer_overloads(arithmetic_template, PRELUDE_MASS.divide)
remainder :: template_integer_overloads(arithmetic_template, PRELUDE_MASS.remainder)

comparison_template :: macro(impl, type : Type) {
  @fn(x : type, y : type) -> (bool) impl
}

less :: template_integer_overloads(comparison_template, PRELUDE_MASS.less)
less_equal :: template_integer_overloads(comparison_template, PRELUDE_MASS.less_equal)
greater :: template_integer_overloads(comparison_template, PRELUDE_MASS.greater)
greater_equal :: template_integer_overloads(comparison_template, PRELUDE_MASS.greater_equal)
equal :: template_integer_overloads(comparison_template, PRELUDE_MASS.equal)
not_equal :: template_integer_overloads(comparison_template, PRELUDE_MASS.not_equal)

logical_shift_left :: PRELUDE_MASS.number_literal_logical_shift_left
logical_shift_right :: PRELUDE_MASS.number_literal_logical_shift_right
bitwise_or :: PRELUDE_MASS.number_literal_bitwise_or
bitwise_and :: PRELUDE_MASS.number_literal_bitwise_and

Array :: fn(item : Type, length : u64) -> (Type) {
  mass :: PRELUDE_MASS
  byte_size :: mass.Descriptor.bit_size.as_u64 * 8
  byte_alignment :: mass.Descriptor.bit_alignment.as_u64 * 8
  t : Type = mass.allocator_allocate_bytes(mass.allocator, byte_size, byte_alignment)
  t.tag = mass.Descriptor_Tag.Fixed_Size_Array
  t.bit_size = [item.bit_size.as_u64 * length]
  t.bit_alignment = item.bit_alignment
  t.Fixed_Size_Array = [item, length]
  t
}

multiply :: Array

external :: fn(
  library_name : String,
  symbol_name : String
) -> (
  result : PRELUDE_MASS.External_Symbol
) {
  result.library_name = library_name
  result.symbol_name = symbol_name
  result
}

syscall :: fn(
  number : s64
) -> (
  result : PRELUDE_MASS.Syscall
) {
  result.number = number
  result
}

negate :: template_signed_integer_overloads(macro(impl, type : Type) {
  macro(x : type) -> (type) { 0 - x }
}, ())
negate :: @fn(literal : Number_Literal) -> (Number_Literal) {
  // FIXME this cast should not be necessary
  literal.negative = if literal.negative then cast(u32, false) else true
  literal
}

